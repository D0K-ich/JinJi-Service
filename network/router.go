package network

import (
	"fmt"
	"github.com/rs/zerolog/log"
	"strconv"
	"runtime/debug"
	"encoding/json"

	"github.com/fasthttp/router"
	"github.com/valyala/fasthttp"
	"github.com/fasthttp/session/v2"
	"github.com/D0K-ich/types/message"

	"github.com/D0K-ich/JinJi-Service/handlers/users"
)

const (
	cookieKeyUser  = "user_id"
	cookieKeyAdmin = "admin_id"
)

func CreateRouter(files_path string, admin_token string, user_session *session.Session) (main_router *router.Router) {
	main_router = router.New()

	main_router.PanicHandler = func(ctx *fasthttp.RequestCtx, i interface{}) {
		debug.PrintStack()
		log.Error().Msgf("Panic detected", "err", i)
		ctx.Error("Internal error", fasthttp.StatusInternalServerError)
		return
	}

	main_router.NotFound = func(ctx *fasthttp.RequestCtx) {
		log.Info().Msgf("(rest) >> NOT FOUND HANDLER", "method", string(ctx.Method()), "path", string(ctx.Path()))
		if ctx.IsGet() {
			return
		}
		writeError(ctx, "handler not found")
		return
	}

	main_router.MethodNotAllowed = func(ctx *fasthttp.RequestCtx) {
		log.Info().Msgf("(rest) >> NOT ALLOWED METHOD","method", string(ctx.Method()), "path", string(ctx.Path()))
		writeError(ctx, "method not allowed")
		return
	}

	main_router.POST("/admin/{subject}/{action?}", func(ctx *fasthttp.RequestCtx) {
		//var response *http.Response
		//response = admins.NewHandler()
		//
		//ctx.SetStatusCode(response.StatusCode())
		//ctx.SetBody(response.Serialize())
		//ctx.SetContentType(message.ContentTypeJson)
	})

	main_router.POST("/user/{subject}/{action}", func(ctx *fasthttp.RequestCtx) {
		var err error
		var session_store *session.Store
		session_store, err = user_session.Get(ctx)
		if err != nil {ctx.Error(err.Error(), fasthttp.StatusInternalServerError);return}

		var user_id int
		var check_cookie = session_store.Get(cookieKeyUser)
		if check_cookie != nil {if user_id, err = strconv.Atoi(fmt.Sprintf("%v", session_store.Get(cookieKeyUser))); err != nil {return}} //todo

		log.Debug().Msgf("Cookie", "is nil:", check_cookie == nil)

		var handler = users.NewHandler(user_id)

		var new_user_id int
		if new_user_id = handler.UserId(); new_user_id == user_id {
			session_store.Set(cookieKeyUser, new_user_id)
			if err = user_session.Save(ctx, session_store); err != nil {
				ctx.Error(err.Error(), fasthttp.StatusInternalServerError)
				return
			}
		}

		var incoming *message.Message
		if incoming, err = message.FromJson(ctx.PostBody()); err != nil {
			writeError(ctx, "failed to decode body: " + err.Error())
			return
		}

		//todo legacy
		var subject = ctx.UserValue("subject").(string)
		var action 	= ctx.UserValue("action").(string)
		incoming.SetModule("user")
		incoming.SetSubject(subject)
		incoming.SetAction(action)


		var response any
		if response, err = handler.Route(incoming); err != nil {
			writeError(ctx, fmt.Sprintf("err response generated by server. err %s", err.Error()))
			return
		}

		var response_byte []byte
		if response_byte, err = json.Marshal(response); err != nil {return}

		ctx.SetStatusCode(fasthttp.StatusOK)
		ctx.SetBody(response_byte)
		ctx.SetContentType("application/json")
	})

	return
}

func fsHandler(root string, stripSlashes int) fasthttp.RequestHandler {
	var fs = &fasthttp.FS{
		Root:               root,
		IndexNames:         []string{"index.html"},
		GenerateIndexPages: false,
		AcceptByteRange:    false,
	}
	if stripSlashes > 0 {
		fs.PathRewrite = fasthttp.NewPathSlashesStripper(stripSlashes)
	}
	return fs.NewRequestHandler()
}
